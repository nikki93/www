<!doctype html>
<html lang="">	
<head>
<meta charset="utf-8"/>
<title>life update: art, proto{cols',',types} - nikhilesh.info</title>	
<meta name="author" content="Nikhilesh Sigatapu">

<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0">

<link href='http://fonts.googleapis.com/css?family=Droid+Sans:700,400|Droid+Sans+Mono' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="http://www.nikhilesh.info/theme/css/main.css" type="text/css" />

<!--[if lt IE 9]>
    <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->


<link href="http://www.nikhilesh.info/" type="application/atom+xml" rel="alternate" title="nikhilesh.info ATOM Feed" />
</head>

<body>		
<header class="clearfix" role="banner">
    <div class="wrapper">
        <h1 class="huge"><a href="http://www.nikhilesh.info">nikhilesh.info</a></h1>
    </div>
</header>

<div class="wrapper pages">
    <ul class="nav">
 <li><a href="http://www.nikhilesh.info/pages/about.html">about</a></li>  <li><a href="http://www.nikhilesh.info/pages/projects.html">projects</a></li>         <li class="sep">&nbsp;</li>
        <li><a href="http://www.nikhilesh.info/archives.html">archive</a></li>
        <li class="sep">&nbsp;</li>
        <li><a href="mailto:s.nikhilesh@gmail.com">email</a></li>
        <li><a href="https://github.com/nikki93">github</a></li>
    </ul>
</div>

<div role="main" class="content clearfix">	
	<article>
		<div class="post wrapper">
			<h1>life update: art, proto{cols',',types}</h1>

			<p><a href="http://www.nikhilesh.info/images/pgame.png">
    <img class="screenshot" src="http://www.nikhilesh.info/images/pgame.png"
        alt="lgame with old sprites, pgame with... no sprites" />
</a></p>
<p>Yup, it's happening again. Now it's <a href="https://github.com/nikki93/pgame">pgame</a>.</p>
<h2>(Philosophy) Game development tools... Why games? Why development tools?</h2>
<p>So the past year has been quite inspiring in philosophical terms. I realized that my trajectory so far is I started playing games, then found making games more fun, then I realized making game-development tools is more fun. :) Starting with Game Maker then going through object models, serialization and stuff like that, I've found a few things to be important (some of these correspond to the principles outlined in the <a href="http://www.nikhilesh.info/files/cgame.pdf">cgame paper</a> or the <a href="http://www.nikhilesh.info/files/cgame-poster.pdf">poster</a>):</p>
<ul>
<li><strong>save/load:</strong> Users often want to save/load games at any point, and your game shouldn't need too much to implement this. But not just that, a good way to build a level is to serialize the live level. So many other things are nice with serialization (see the cgame paper for more). We want it to be automatic for all objects, and in fact the manual specification should be for exceptions to the rule. </li>
<li><strong>live property editing:</strong> Allows quicker debugging and experimentation with ideas.</li>
<li><strong>live functionality editing:</strong> Editing 'code.' For same reason as live property editing.</li>
<li><strong>a principle of abstraction that supports the above</strong> The above points should extend not just to built-in elements, but to <em>anything</em> the user can come up with and make using your tool. Ever. Any new logic the user writes, any new data types, and in a way that applies to the problem at hand--for example, some numbers are better specified in the editor visually, like a direction to face (check out Pharo's inspectors).</li>
</ul>
<p>The last one is the tough one. For cgame, the principle was "use an entity-system," detailed in the poster and paper.</p>
<p>Over time I've seen different ideas. C++/Java with class-style object orientation where classes are conflated with static types. More proper static typing a la Haskell but also functional things and the confluence of the two into monads (traditional Haskell IO) or streams (like Elm) (arguable one reducible to the other but reducability isn't sufficient). With functional I realized that this is one reason games are interesting: they are highly "current state" and "event based." You react to input events from the player, but even without such input things go crazy with AI enemies fighting each other or such. Implementing a compiler means implementing a function of type <code>SourceodeA -&gt; Either Error SourcecodeB</code>--a compiler is a transformation, and 'functional' is nice for writing those. What function is the game? Sorta hard. 'Functional relational programming' is a nice thing to check out here, where the model in a functional reactive model becomes a relational database, ensuring same-time constraints along with across-time constarints, using a mix of declarative/logic/SQLy and functional stuff. More resources on this: <a href="http://shaffner.us/cs/papers/tarpit.pdf">one</a>, <a href="http://incidentalcomplexity.com/">two</a>, <a href="http://unisonweb.org/">three</a>.</p>
<p>Another reason games are interesting is that we are trying to build an aesthetic end product. It's not judged simply by "it's 80% faster" but "hey so I played this thing and I guess it's kinda sorta fun but like it depends on taste." So you want that immediate artist-artwork feedback loop you have when painting on an easel without a blindfold on or playing drums without earplugs in. Let's make games with the blindfold off.</p>
<p>Getting a little abstract there. But yeah that connects, I think, with the live coding point. I'd go as far as saying static typing is actually a hindrance to such right-brained activity. I'd rather work on the game proceed in cycles of right-brained 'creativity' (live coding with everything late-bound) followed by more left-brained 'crystallization' (most testing / solidifying activity, with static types helping here). Much like the cycle of paradigms in Kuhn's <a href="https://en.wikipedia.org/wiki/The_Structure_of_Scientific_Revolutions"><em>The Structure of Scientific Revolutions</em></a>, and the right-brained crystallization periods along the lines of the 'metaphors' in Bohm and Peat's <a href="http://www.amazon.com/Science-Order-Creativity-Dramatic-Creative/dp/0553344498"><em>Science, Order, and Creativity</em></a>, except applied to a much localized and quicker process in the game creator(s) mind(s) rather than generations of scientists. I went pretty far down this rabbit hole, other reads including Nietzsche's works (esp. <em>The Gay Science</em>, <em>Beyond Good and Evil</em>). To live code with ultimate freedom you need to be able to change a thing's type.</p>
<p><img alt="man I love this picture" src="http://worrydream.com/ABriefRantOnTheFutureOfInteractionDesign/Images/Tool2.png" /></p>
<p><em>(picture from Bret Victor's <a href="http://worrydream.com/ABriefRantOnTheFutureOfInteractionDesign/"><em>A Brief Rant on The Future of Interaction Design</em></a>)</em></p>
<p>You need a system with a good "part that fits the problem" but also a good "part that fits the human" (inspired by Bret Victor's <a href="http://worrydream.com/ABriefRantOnTheFutureOfInteractionDesign/"><em>A Brief Rant on The Future of Interaction Design</em></a>). To this end, it must be informed not just by theory, but also by human psychology. Math is good if the theories are solid and proved, but even better if the proofs are elgant and simple in a way that lends itself to use by humans for building more math or whatever else. So I have tried to draw inspiration from everyone and how they work, especially how they work on tasks that demand aestheticism.</p>
<p>Again, bringing us back to the aestheticism surrounding games. Aeshetic end-points requiring creative work, testing our purpose of <a href="http://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html">providing computer support for the creative spirit in everyone</a>--that's a good paper on the design of Smalltalk you should check out. It says, "If a system is to serve the creative spirit, it must be entirely comprehensible to a single individual." and I'd go far as saying that "it must be entirely created by a single individual" :) In all seriousness though, if it takes too long to make and too many people, it's probably too complicated. The system should be so good that as it is being built it helps itself be built. Like how morphs in Self exploit the prototype inheritance, and how cgame's editor GUI is itself built using the entity-system model.</p>
<p>Making development tools is also nice in that you're not just 'building a service' that people want to not think about and use and forget (like a search engine that answers the question and gets out of your way), but something that they are engaged in conversation with and work with together, like Ableton Live is to the music-maker or Photoshop for the artist. If you're a lumberjack, it's your axe that you so admire, not your kitchen tap you never thought twice about. It isn't quite as taken for granted. And if it is a development tool for developers, the 'end-user' can actually code and release libraries, even bugfixes for your own tool, allowing for community aspects like the one surrounding the Ogre forums.</p>
<p>This brings us to yet another point, which is education. Would you rather tell a kid, "Hey, I'm gonna teach you what a for loop is, we're gonna print 10 numbers!" or  "Hey, I'm gonna teach you what a for loop is, we're gonna make 10 space invaders enemies appear on screen!" What's more, kids are less informed (more like 'limited by') socialization into a current status quo for what makes a good game or a good piece of art, and would make some really cool things that I wanna see.</p>
<p>Lastly, I've been doing games for a while and have an accumulation of ideas in my head regarding what makes them annoying, and every decision I make sort of gives me flashbacks of past issues and a gut feeling about whether it's gonna help that issue.</p>
<p>Oh and, did I mention that... Games are just fun anyways? You might already know this.</p>
<p>Yeah, I wanna make game development tools.</p>
<h2>(Idea) Prototype-based programming</h2>
<p>This is "a principle of abstraction that supports the above." The idea is: <em>make abstractions concrete enough</em> that they can be save/loaded and live edited.</p>
<p>See how that makes the principle 'support the above'? In the spirit of concreteness, what I mean is: things that we think of as 'classes' and 'types' (which are abstractions) should be actual tangible entities, that you can edit and play around with, the <em>very same</em> way you would play with 'instances' of those classes and types (their 'concretizations'). Tangible like for a sculptor with hands-on control of their art piece.</p>
<p>If we do this to the extent that an abstraction of an instance is literally the same 'kind of thing' as an instance (they are both now called 'entities'), then we should get this for free. They are <a href="https://en.wikipedia.org/wiki/Brahman">made of the same stuff</a>. The abstraction is also now clay in the sculptor's hands.</p>
<p>Enter prototype-based programming.</p>
<p><em>(Gilad Bracha goes far as to apply the abstract-to-concrete approach to <a href="http://gbracha.blogspot.ca/2012/11/debug-mode-is-only-mode.html">'functions' vs. 'running instances of functions'</a>)</em></p>
<p><em>(stay tuned for a more in-depth idea description)</em></p>
			
			
		</div>
	
<div class="meta wrapper">
	<time datetime="2015-09-17T00:00:00" pubdate>Thu 17 September 2015</time>
	<ul class="tag clearfix">
		<li><a href="http://www.nikhilesh.info/category/coding.html">coding</a></li>
	</ul>
</div>	</article>	
</div>

<footer class="clearfix">
    <div class="copy wrapper">
        <p role="contentinfo">© 2013 Nikhilesh Sigatapu<br>
    </div>
</footer>

<script>
var _gaq=[['_setAccount',''],['_trackPageview']];
(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
 g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
 s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
</body>
</html>
